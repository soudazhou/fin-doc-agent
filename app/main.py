# =============================================================================
# Financial Document Q&A Agent — FastAPI Application Entry Point
# =============================================================================
#
# This is the main entry point for the API server.
#
# RUN LOCALLY:
#   uvicorn app.main:app --reload
#
# RUN WITH DOCKER:
#   docker compose up
#
# API DOCUMENTATION (auto-generated by FastAPI):
#   - Swagger UI: http://localhost:8000/docs
#   - ReDoc:      http://localhost:8000/redoc
#   - OpenAPI JSON: http://localhost:8000/openapi.json
#
# ARCHITECTURE:
# This file is intentionally thin — it only:
# 1. Creates the FastAPI application instance
# 2. Configures lifespan events (startup/shutdown)
# 3. Includes API routers from app/api/
# 4. Defines the health check endpoint
#
# All business logic lives in app/services/, app/agents/, and app/workers/.
# This separation keeps the entry point clean and testable.
# =============================================================================

import logging
from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from pathlib import Path

from fastapi import FastAPI

from app.api.admin import router as admin_router
from app.api.ask import router as ask_router
from app.api.audit import AuditLoggingMiddleware
from app.api.benchmark import router as benchmark_router
from app.api.evaluate import router as evaluate_router
from app.api.ingest import router as ingest_router
from app.config import settings
from app.db.engine import async_engine
from app.db.models import Base
from app.models.responses import HealthResponse

# ---------------------------------------------------------------------------
# Logging Configuration
# ---------------------------------------------------------------------------
# Structured logging is critical for production AI systems.
# In a real deployment, you'd use JSON logging (e.g., structlog) and
# ship logs to a service like Datadog or CloudWatch for monitoring.
# For this demo, standard Python logging is sufficient.
# ---------------------------------------------------------------------------
logging.basicConfig(
    level=logging.DEBUG if settings.debug else logging.INFO,
    format="%(asctime)s | %(levelname)-8s | %(name)s | %(message)s",
)
logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Application Lifespan — Startup & Shutdown Events
# ---------------------------------------------------------------------------
# DESIGN DECISION: We use FastAPI's lifespan context manager (not the
# deprecated @app.on_event decorators). The lifespan pattern:
# 1. Runs startup logic before `yield`
# 2. Runs shutdown logic after `yield`
# 3. Properly handles cleanup even on crash
#
# Startup:
#   - Creates database tables if they don't exist (dev convenience)
#   - In production, you'd use Alembic migrations instead
#
# Shutdown:
#   - Disposes the database engine (closes all connections)
#   - Prevents connection leaks
# ---------------------------------------------------------------------------
@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """
    Manage application startup and shutdown lifecycle.

    On startup: Create database tables (development convenience).
    On shutdown: Clean up database connections.
    """
    # --- Startup ---
    logger.info("Starting %s v%s", settings.app_name, settings.app_version)

    # Create tables if they don't exist.
    # NOTE: In production, replace this with Alembic migrations.
    # `create_all` is safe to call multiple times — it's a no-op for
    # tables that already exist (it checks the schema first).
    async with async_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    logger.info("Database tables verified/created")

    # Ensure upload directory exists for PDF ingestion (Phase 2)
    upload_dir = Path(settings.upload_dir)
    upload_dir.mkdir(parents=True, exist_ok=True)
    logger.info("Upload directory: %s", upload_dir.resolve())

    yield

    # --- Shutdown ---
    logger.info("Shutting down %s", settings.app_name)
    await async_engine.dispose()
    logger.info("Database connections closed")


# ---------------------------------------------------------------------------
# FastAPI Application Instance
# ---------------------------------------------------------------------------
# Key configuration:
# - title/description: Shown in auto-generated API docs (/docs)
# - version: Follows semver, shown in docs and health endpoint
# - lifespan: Startup/shutdown event handler (defined above)
#
# The OpenAPI docs are one of FastAPI's killer features for demos —
# they provide an interactive API explorer out of the box.
# ---------------------------------------------------------------------------
app = FastAPI(
    title=settings.app_name,
    description=(
        "A multi-agent RAG system for answering questions over financial documents. "
        "Built with FastAPI, LangGraph, pgvector, and Claude."
    ),
    version=settings.app_version,
    lifespan=lifespan,
)


# ---------------------------------------------------------------------------
# API Routers
# ---------------------------------------------------------------------------
# Each router handles a specific domain. Adding them here keeps main.py thin.
#
# Phase 2: Document ingestion (upload, parse, chunk, embed, store)
# Phase 3: Question answering (/ask)
# Phase 4: Benchmarking & comparison (/compare, /benchmark, /metrics)
# Phase 5: Evaluation (/evaluate, /evaluate/runs, /evaluate/history, /evaluate/failures)
# Phase 6: Admin & auth (/admin/keys, /admin/audit)
# ---------------------------------------------------------------------------
app.include_router(ingest_router)
app.include_router(ask_router)
app.include_router(benchmark_router)
app.include_router(evaluate_router)
app.include_router(admin_router)


# ---------------------------------------------------------------------------
# Middleware
# ---------------------------------------------------------------------------
# Audit logging middleware records every request to the audit_logs table.
# Registered after routers so it wraps the entire request lifecycle.
# ---------------------------------------------------------------------------
app.add_middleware(AuditLoggingMiddleware)


# ---------------------------------------------------------------------------
# Health Check Endpoint
# ---------------------------------------------------------------------------
# A health check endpoint is essential for:
# 1. Container orchestration (Docker health checks, K8s liveness probes)
# 2. Load balancer health monitoring
# 3. Smoke testing deployments
#
# This is a simple "is the process running?" check. For production,
# you'd add deeper checks (DB connectivity, Redis connectivity, etc.)
# and expose them at /health/ready (readiness) vs /health/live (liveness).
# ---------------------------------------------------------------------------
@app.get(
    "/health",
    response_model=HealthResponse,
    tags=["System"],
    summary="Health check",
    description=(
        "Verify the API is running. "
        "Used by Docker health checks and load balancers."
    ),
)
async def health_check() -> HealthResponse:
    """Return basic health status."""
    return HealthResponse(
        status="ok",
        version=settings.app_version,
        service=settings.app_name,
    )
